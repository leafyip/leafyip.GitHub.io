---
title: Rabbitmq高可用
date: 2020-10-12 21:02:36
tags: MQ
---

rabbitmq支持集群方式实现高可用.
# 1 集群的节点类型
多个rabbitmq实例组成rabbitmq集群.
rabbitmq集群的节点可分为内存节点和磁盘节点.

## 1.1 内存节点:
<font color='red'>将所有的队列(Queue),交换器(exchange),绑定(binding),用户(user),权限和虚拟主机(vhost) 的<font color='green'>元数据</font>定义都仅存储在内存中</font>

<font size='4'>注意:是保存元数据信息,而不是队列里的消息.</font>
<font size='4'>内存节点重启会清空所有的元数据信息,然后从磁盘节点同步元数据信息</font>
## 1.2 磁盘节点
<font color='red'>将所有的元数据保存在磁盘中</font>

一个集群中至少要有一个磁盘节点.有新节点加入或者离开集群时,新节点会将变动至少通知到一个磁盘节点.如果系统中唯一的磁盘节点宕机,整个集群依然可以继续路由已经存在的消息,
但是无法执行以下操作
<!--more-->
	 创建队列
	 创建交互器
	 创建绑定
	 添加用户
	 更改权限

分析 : 因为没有磁盘节点的话,假如能创建队列,那队列的元信息会保存在内存节点中.而内存节点重启会丢失元数据,导致集群数据丢失.

如果有多个磁盘节点,且磁盘节点的元数据不一致.可以尝试停止集群,然后按顺序重启节点,第一个启动持有最多正确元数据的磁盘节点,然后再添加其他节点.

## 1.3 节点类型和消息持久化
无论是磁盘节点还是内存节点都可以持久化消息. 
因为磁盘和内存节点的划分依据是该节点是否保存元数据到磁盘. 而消息的持久化是指将消息持久化到磁盘.

# 2 集群的队列.

## 2.1 普通队列 
默认情况下,在集群中创建队列,集群只会在单一节点上创建完整的队列信息.完整的队列信息包括 元数据 + 消息内容等,其中元数据是所有节点都共享的,但消息的内容只保存在某一个具体的节点.

如图,客户端在集群创建了<font color='red'>普通队列</font> ,队列名称为`hello_world` 实际上集群是在`node2`节点创建了该队列.
此时如果消费者向`node3` (`node1`也同理)节点拉取`hello_world`,过程如下

1. `node3`节点通过元数据得知`hello_world`节点在`node2`节点上,
2. 那么`node3`会向`node2`拉取消费者所需要的数据,然后直接返回数据给消费者,
3. 拉取完数据后,`node3` 也不会保存`hello_world`的数据.

![Alt text](/images/rabbitmq_normal_cluster_send.png)


普通队列存在的问题
单一节点挂机后,该节点所有的未持久化队列都将丢失数据,持久化队列虽然可以重启恢复原有队列的数据.
但是在该节点宕机到重启的这段时间内,消费者将丢失其订阅的消息,而发布者如果未启用`发布确认` 或 `事务机制` ,也会丢失新的消息



## 2.2 高可用(镜像)队列
在rabbitmq集群中,可将符合一定正则表达式的队列设置为镜像队列.
如
`./rabbitmqctl set_policy -p wenda-action mirrored_queue_policy_all ".*_mirrored_queue" '{"ha-mode":"all"}'`

之后新建的所有满足“*_mirrored_queue”规则的队列都是镜像队列

镜像队列会在所有节点中创建副本

如图,客户端在集群创建了<font color='red'>镜像队列</font> ,队列名称为`ha_mirrored_queue` 那么所有节点都会创建了该队列.
此时如果消费者向哪一个节点都能直接获取数据

![Alt text](/images/rabbitmq_mirror_cluster_send.png)


# 3升级集群节点
+ 先备份当前系统配置
+ 关闭所有生产者,并等待消费者将所有队列的消息都消费完
+ 解压新版本的rabbitmq到原来的安装目录
+ 先启动磁盘节点,然后再启动内存节点